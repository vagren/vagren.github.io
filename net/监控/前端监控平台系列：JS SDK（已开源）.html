<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>背景 | WebCourse</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/assets/style.49eed234.css">
    <link rel="modulepreload" href="/assets/Home.e02e0cd4.js">
    <link rel="modulepreload" href="/assets/app.79b189f8.js">
    <link rel="modulepreload" href="/assets/net_监控_前端监控平台系列：JS SDK（已开源）.md.994dd3cf.lean.js">
    
    <meta name="twitter:title" content="背景 | WebCourse">
  <meta property="og:title" content="背景 | WebCourse">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="WebCourse, back to home" data-v-675d8756 data-v-cc01ef16><!----> WebCourse</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><!----></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><!----><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#国内常用的监控平台">国内常用的监控平台</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么不选择上面三个监控平台或者其他监控平台，为什么要自己搞？">为什么不选择上面三个监控平台或者其他监控平台，为什么要自己搞？</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#整体流程">整体流程</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#整体代码架构">整体代码架构</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#web错误信息收集">web错误信息收集</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#接口错误">接口错误</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#js代码错误-资源错误">js代码错误&amp;&amp;资源错误</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#监听unhandledrejection">监听unhandledrejection</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#用户行为信息收集">用户行为信息收集</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#dom事件信息">dom事件信息</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#路由切换信息">路由切换信息</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#console信息">console信息</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#框架层错误信息收集">框架层错误信息收集</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#vue">Vue</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#react">React</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#自定义上报错误">自定义上报错误</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#breadcrumb收集">Breadcrumb收集</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#类型整合">类型整合</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#error-id生成">Error id生成</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#上报错误信息">上报错误信息</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#通过xhr上报">通过xhr上报</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#image的形式来发送请求">Image的形式来发送请求</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#navigator-sendbeacon">Navigator.sendBeacon</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#用户唯一标识">用户唯一标识</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#sdk小结">SDK小结</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#关于开源">关于开源</a><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-hidden="true">#</a></h1><p>传统方式下一个前端项目发到正式环境后，所有报错信息只能通过用户使用时截图、口头描述发送到开发者，然后开发者来根据用户所描述的场景去模拟这个错误的产生，这效率肯定超级低，所以很多开源或收费的前端监控平台就应运而生，比如:</p><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetsentry%2Fsentry" target="_blank" rel="noopener noreferrer">sentry</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fa597873885%2Fwebfunny_monitor" target="_blank" rel="noopener noreferrer">webfunny</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.fundebug.com%2F" target="_blank" rel="noopener noreferrer">fundebug</a></li></ul><p>等等一些优秀的监控平台</p><h2 id="国内常用的监控平台" tabindex="-1">国内常用的监控平台 <a class="header-anchor" href="#国内常用的监控平台" aria-hidden="true">#</a></h2><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgetsentry%2Fsentry" target="_blank" rel="noopener noreferrer">sentry</a> ：从监控错误、错误统计图表、多重标签过滤和标签统计到触发告警，这一整套都很完善，团队项目需要充钱，而且数据量越大钱越贵</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.fundebug.com%2F" target="_blank" rel="noopener noreferrer">fundebug</a>：除了监控错误，还可以录屏，也就是记录错误发生的前几秒用户的所有操作，压缩后的体积只有几十 KB，但操作略微繁琐</p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fa597873885%2Fwebfunny_monitor" target="_blank" rel="noopener noreferrer">webfunny</a>：也是含有监控错误的功能，可以支持千万级别日PV量，额外的亮点是可以远程调试、性能分析，也可以<code>docker</code>私有化部署（免费），业务代码加密过</p><h2 id="为什么不选择上面三个监控平台或者其他监控平台，为什么要自己搞？" tabindex="-1">为什么不选择上面三个监控平台或者其他监控平台，为什么要自己搞？ <a class="header-anchor" href="#为什么不选择上面三个监控平台或者其他监控平台，为什么要自己搞？" aria-hidden="true">#</a></h2><ol><li>首先<code>sentry</code>和<code>fundebug</code>需要投入大量金钱来作为支持，而<code>webfunny</code>虽是可以用<code>docker</code>私有化部署，但由于其代码没有开源，二次开发受限</li><li>自己开发可以将公司所有的SDK统一成一个，包括但不限于：埋点平台SDK、性能监控SDK</li></ol><h1 id="监控平台的组成" tabindex="-1">监控平台的组成 <a class="header-anchor" href="#监控平台的组成" aria-hidden="true">#</a></h1><h2 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-hidden="true">#</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4177c91ce6e047508d4d942bd24d6f90~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p><p>整体流程</p><p>从上图可以看出来，如果需要自研监控平台需要做三个部分：</p><ol><li>APP监控SDK：收集错误信息并上报</li><li>server端：接收错误信息，处理数据并做持久化，而后根据告警规则通知对应的开发人员</li><li>可视化平台：从数据存储引擎拿出相关错误信息进行渲染，用于快速定位问题</li></ol><h1 id="监控sdk" tabindex="-1">监控SDK <a class="header-anchor" href="#监控sdk" aria-hidden="true">#</a></h1><h2 id="整体代码架构" tabindex="-1">整体代码架构 <a class="header-anchor" href="#整体代码架构" aria-hidden="true">#</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cedaebef9e0543cabb51d21c67c8a6ce~tplv-k3u1fbpfcp-watermark.awebp" alt="flow"></p><p>代码架构</p><p>整体代码架构使用<strong>发布-订阅</strong>设计模式以便后续迭代功能，处理逻辑基本都在<code>HandleEvents</code>文件中,这样设计的好处是如果想穿插<code>hook</code>或者迭代功能可以在处理事件回调多添加一个函数</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12dc2e0ffe3342dda7d2421e1ccf633e~tplv-k3u1fbpfcp-watermark.awebp" alt="handlerEvent"></p><p>HandleEvents</p><h2 id="web错误信息收集" tabindex="-1">web错误信息收集 <a class="header-anchor" href="#web错误信息收集" aria-hidden="true">#</a></h2><p>一般情况下都是通过重写js原生事件然后拿到错误信息，比如<code>ajax请求</code>，通过重写<code>xhr</code>、<code>fetch</code>事件来截取接口信息，所以我们需要优先编写一个易于重写事件的函数来复用。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9828fb478366475eb547e7f26f15f0fd~tplv-k3u1fbpfcp-watermark.awebp" alt="replaceOld"></p><p>replaceOld</p><h3 id="接口错误" tabindex="-1">接口错误 <a class="header-anchor" href="#接口错误" aria-hidden="true">#</a></h3><p>所有的请求第三方库都是基于<code>xhr</code>、<code>fetch</code>二次封装的，所以只需要重写这两个事件就可以拿到所有的接口请求的信息，通过判断<code>status</code>的值来判断当前接口是否是正常的。举个例子，重写<code>xhr</code>的代码操作：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd243877a254af9a38db722a3ba8872~tplv-k3u1fbpfcp-watermark.awebp" alt="xhrReplace"></p><p>Xhr重写</p><p>上面除了拿去接口的信息之外还做一个操作：如果是SDK发送的接口，就不用收集该接口的信息。如果需要发布事件就调用<code>triggerHandlers(EVENTTYPES.XHR, this.mito_xhr)</code>，类似的，<code>fetch</code>也是用这种方式来重写。</p><p><strong>关于接口跨域、超时的问题</strong>：这两种情况发生的时候，接口返回的响应体和响应头里面都是空的，<code>status</code>等于0，所以很难区分两者，但是正常情况下，一般项目中都的请求都是复杂请求，所以在正式请求会先进行<code>option</code>进行预请求，如果是跨域的话基本几十毫秒就会返回来，所以以此作为临界值来判断跨域与超时的问题（如果是接口不存在也会被判断成接口跨域）。</p><h3 id="js代码错误-资源错误" tabindex="-1">js代码错误&amp;&amp;资源错误 <a class="header-anchor" href="#js代码错误-资源错误" aria-hidden="true">#</a></h3><p>监听<code>window</code>的<code>error</code>事件</p><div class="language-js line-numbers-mode"><pre><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;error&#39;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 拿到错误信息，发布事件：triggerHandlers</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
复制代码
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>资源错误</li></ul><p>判断<code>e.target.localName</code>是否有值，有的话就是资源错误，在<code>handleErrors</code>中拿到信息：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65de8d85fde74d6daaaace8b4031e550~tplv-k3u1fbpfcp-watermark.awebp" alt="handleError"></p><p>handleError</p><ul><li>代码错误</li></ul><p>上面判断为<code>false</code>时，代表是代码错误，在回调中可以拿到对应的错误代码文件、代码行数等等信息，然后通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map" target="_blank" rel="noopener noreferrer">source-map</a>这个<code>npm包</code><strong>+</strong><code>sourceMap</code>文件进行解析，就可以还原出线上真实代码错误的位置。</p><h3 id="监听unhandledrejection" tabindex="-1">监听unhandledrejection <a class="header-anchor" href="#监听unhandledrejection" aria-hidden="true">#</a></h3><p>当<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a> 被 <code>reject</code> 且没有 <code>reject</code> 处理器的时候，会触发 <code>unhandledrejection</code> 事件</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aec6dd1514d84a28b62a1c43836f0b07~tplv-k3u1fbpfcp-watermark.awebp" alt="replaceUnhandlerejecttion"></p><p>unhandledrejection监听</p><h2 id="用户行为信息收集" tabindex="-1">用户行为信息收集 <a class="header-anchor" href="#用户行为信息收集" aria-hidden="true">#</a></h2><p>单纯收集错误信息是可以提高错误定位的效率，但如果再配合上用户行为的话就锦上添花，定位错误的效率再上一层，如下图所示，可以清晰的看到用户做了哪些事：进了哪个页面 =&gt; 点击了哪个按钮 =&gt; 触发了哪个接口：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/951cbdde52f74f76babe6d67b8b1b835~tplv-k3u1fbpfcp-watermark.awebp" alt="breadcrumb"></p><p>用户行为前端页面展示</p><h3 id="dom事件信息" tabindex="-1">dom事件信息 <a class="header-anchor" href="#dom事件信息" aria-hidden="true">#</a></h3><p><code>dom</code>事件获取包括很多：<code>click</code>、<code>input</code>、<code>doubleClick</code>等等，一种直接在window上面监听click事件（注意第三个参数为<code>true</code>）:</p><div class="language-javascript line-numbers-mode"><pre><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// 利用节流，以防事件触发过快</span>
  <span class="token comment">// 发布事件 triggerHandlers</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
复制代码
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>还有一种是通过重写<code>window.addEventListener</code>的方式来截取开发者对dom的监听事件。</p><h3 id="路由切换信息" tabindex="-1">路由切换信息 <a class="header-anchor" href="#路由切换信息" aria-hidden="true">#</a></h3><p>在单页应用中有两种路由变换：<strong>hashchange</strong>、<strong>history</strong></p><ul><li><strong>history</strong></li></ul><p>当浏览器支持<code>history</code>模式时，会被以下两个事件所影响：<code>pushState</code>、<code>replaceState</code>，且这两个事件不会触发<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2Fonpopstate" target="_blank" rel="noopener noreferrer">onpopstate</a>的回调，所以我们需要监听这个三个事件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16ae443e6d147b98f58a3c215487ec8~tplv-k3u1fbpfcp-watermark.awebp" alt="onpopstate"></p><p>onpopstate重写</p><ul><li><strong>hashchange</strong></li></ul><p>当浏览器只支持<code>hashchange</code>时，就需要重写hashchange:</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761c35ea7b6b4c2788eaa1777c740efe~tplv-k3u1fbpfcp-watermark.awebp" alt="hashchange"></p><p>hashchange重写</p><h3 id="console信息" tabindex="-1">console信息 <a class="header-anchor" href="#console信息" aria-hidden="true">#</a></h3><p>正常情况下正式环境是不应该有<code>console</code>的，那为什么要收集<code>console</code>的信息？第一：非正常情况下，正式环境或预发环境也可能会有<code>console</code>，第二：很多时候也可以把<code>sdk</code>放入测试环境上面调试。所以最终还是决定收集<code>console</code>信息，但是在初始化的时候的传参来告诉<code>sdk</code>是否监听<code>console</code>的信息收集。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1adbf0daa6014d3aa4b9d6ab27a1fd6d~tplv-k3u1fbpfcp-watermark.awebp" alt="relaceConsole"></p><p>console重写</p><h2 id="框架层错误信息收集" tabindex="-1">框架层错误信息收集 <a class="header-anchor" href="#框架层错误信息收集" aria-hidden="true">#</a></h2><h3 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-hidden="true">#</a></h3><div class="language-"><pre><code>vue2.6`官网提供了两个报错函数的回调：`Vue.config.errorHandler`和`Vue.config.warnHandler
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39b257267bb0447a84a266a0723dd661~tplv-k3u1fbpfcp-watermark.awebp" alt="errorHandle"></p><p>vue错误信息收集</p><h3 id="react" tabindex="-1">React <a class="header-anchor" href="#react" aria-hidden="true">#</a></h3><p>React16.13中提供了<a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-component.html%23componentdidcatch" target="_blank" rel="noopener noreferrer">componentDidCatch</a>钩子函数来回调错误信息，所以我们可以新建一个类<code>ErrorBoundary</code>来继承React，然后然后声明<code>componentDidCatch</code>钩子函数，可以拿到错误信息（目前没写react的错误收集，看官网文档简述，简易版应该是这样写的）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d4d7577447542198722c218775874d2~tplv-k3u1fbpfcp-watermark.awebp" alt="react-errro"></p><p>react错误信息收集</p><h2 id="自定义上报错误" tabindex="-1">自定义上报错误 <a class="header-anchor" href="#自定义上报错误" aria-hidden="true">#</a></h2><p>上面收集的是web端的代码错误、接口报错和框架层面的报错等等，还有一种是业务错误信息：比如点击支付的时候，可能服务端接口返回200，但是响应体是错误信息，就需要手动上报这块的错误信息。既然要手动上报，<code>SDK</code>就需要提供一个全局函数功能开发者调用：</p><div class="language-js line-numbers-mode"><pre><code><span class="token keyword">import</span> <span class="token constant">MITO</span> <span class="token keyword">from</span> <span class="token string">&#39;mitojs&#39;</span>
<span class="token constant">MITO</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">info</span><span class="token operator">:</span> <span class="token string">&#39;支付失败，余额不足&#39;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;business&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
复制代码
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="breadcrumb收集" tabindex="-1">Breadcrumb收集 <a class="header-anchor" href="#breadcrumb收集" aria-hidden="true">#</a></h2><p>在上面收集完错误信息的时候，都在最后追加一行<code>breadcrumb.push(data)</code>，这样就可以保存用户的行为轨迹，默认情况设置<code>20</code>长度，也可以在初始化时可配置，但是建议最高不要超过<code>100</code>，因为如果信息过多，内存占用过大，对页面不太友好。</p><h3 id="类型整合" tabindex="-1">类型整合 <a class="header-anchor" href="#类型整合" aria-hidden="true">#</a></h3><p>在每个事件类型的回调的时候都将类型整合：比如用户点击、路由跳转都是属于用户行为，这样做的原因是让开发者更好过滤无用信息和精准定位到需要的信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba1e92ec2a74df19f5899c858e848e9~tplv-k3u1fbpfcp-watermark.awebp" alt="breadcrumb-category"></p><p>用户行为类型整合</p><h2 id="error-id生成" tabindex="-1">Error id生成 <a class="header-anchor" href="#error-id生成" aria-hidden="true">#</a></h2><p>每个错误事件触发时都会有很多信息，我们需要尽量保证每个不同信息的错误生成的id不一样，这边采取的措施是先将每个错误的对象key按照一定规则递归排序，然后根据每个对象的值进行<code>hashCode</code>，得到一串<code>errorId</code></p><h2 id="上报错误信息" tabindex="-1">上报错误信息 <a class="header-anchor" href="#上报错误信息" aria-hidden="true">#</a></h2><p>当SDK拿到错误的所有信息时需要上报到服务端，有几种方式上报服务端</p><h3 id="通过xhr上报" tabindex="-1">通过xhr上报 <a class="header-anchor" href="#通过xhr上报" aria-hidden="true">#</a></h3><p>通过<code>xhr</code>上报，如果设置成异步的时候，当用户跳转新页面或者关闭页面时就会丢失当前这个请求，如果设置成同步，又会让页面造成卡顿的现象</p><p><code>sentry</code>目前是通过<code>xhr</code>发送的，不过它在发送前会推到它设置的一个请求缓冲区<code> _buffer</code>，以此来优化并发请求过多的问题。</p><h3 id="image的形式来发送请求" tabindex="-1">Image的形式来发送请求 <a class="header-anchor" href="#image的形式来发送请求" aria-hidden="true">#</a></h3><p><strong>特点：</strong></p><ol><li>没有跨域问题、</li><li>发 GET 请求之后不需要获取和处理数据、</li><li>服务器也不需要发送数据、</li><li>不会携带当前域名 cookie、不会阻塞页面加载，影响用户的体验，只需 <strong>new Image</strong> 对象、</li><li>相比于 BMP/PNG 体积最小，可以节约 41% / 35% 的网络资源小</li></ol><h3 id="navigator-sendbeacon" tabindex="-1">Navigator.sendBeacon <a class="header-anchor" href="#navigator-sendbeacon" aria-hidden="true">#</a></h3><p>**MDN：**可用于通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FGlossary%2FHTTP" target="_blank" rel="noopener noreferrer">HTTP</a>将少量数据异步传输到Web服务器，统计和诊断代码通常要在 <code>unload</code> 或者 <code>beforeunload</code> 事件处理器中发起一个同步 <code>XMLHttpRequest</code> 来发送数据。同步的 <code>XMLHttpRequest</code> 迫使用户代理延迟卸载文档，并使得下一个导航出现的更晚。下一个页面对于这种较差的载入表现无能为力</p><p><strong>特点：</strong></p><ol><li>发出的是异步请求，并且是<code>POST</code>请求</li><li>发出的请求，是放到的浏览器任务队列执行的，脱离了当前页面，所以不会阻塞当前页面的卸载和后面页面的加载过程，用户体验较好</li><li>只能判断出是否放入浏览器任务队列，不能判断是否发送成功</li><li><code>Beacon API</code>不提供相应的回调，因此后端返回最好省略<code>response body</code></li><li>兼容性不是很友好</li></ol><h2 id="用户唯一标识" tabindex="-1">用户唯一标识 <a class="header-anchor" href="#用户唯一标识" aria-hidden="true">#</a></h2><p>为了方便统计用户量，在每次上报的时候会带一个唯一标识符<code>trackerId</code>，生成这个<code>trackerId</code>的途径有两种：</p><ol><li>如果你是用<code>ajax</code>上报的话，发现<code>cookie</code>中没有带<code>trackerId</code>这个字段，服务端生成并<code>setCookie</code>设置到用户端的<code>cookie</code></li><li>直接用SDK生成，在每次上报之前都判断<code>localstorage</code>是否存在<code>trackerId</code>，有则随着错误信息一起发送，没有的话生成一个并设置到<code>localstorage</code></li></ol><h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h1><h2 id="sdk小结" tabindex="-1">SDK小结 <a class="header-anchor" href="#sdk小结" aria-hidden="true">#</a></h2><p>订阅事件 =&gt; 重写原生事件 =&gt; 触发原生事件（发布事件） =&gt; 拿到错误信息 =&gt; 提取有用的错误信息 =&gt; 上报服务端</p><h2 id="关于开源" tabindex="-1">关于开源 <a class="header-anchor" href="#关于开源" aria-hidden="true">#</a></h2><p>SDK开源:<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FclouDr-f2e%2Fmitojs" target="_blank" rel="noopener noreferrer">mitojs</a>，下一篇会讲服务端的表结构设计思路、怎样在<strong>千万</strong>条数据中多重标签<strong>毫秒</strong>级查询错误事件以及更好的告警机制通知开发人员</p><p><strong>感兴趣的小伙伴可以点个关注，后续好文不断！！！</strong></p></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"base_angular_index.md\":\"b7fb98d8\",\"base_aot_aot.md\":\"c43520f0\",\"base_babel_advanced.md\":\"63d342bd\",\"base_babel_babel.md\":\"08db37cd\",\"base_babel_index.md\":\"7eeed92e\",\"base_c_index.md\":\"b4d74b36\",\"base_centos_index.md\":\"a9a38139\",\"base_chrome.google_chrome.md\":\"9ab68b28\",\"base_chrome_chrome.md\":\"d5478063\",\"base_css_css.md\":\"53cfe2c2\",\"base_docker_index.md\":\"ce74c680\",\"base_eclipse_index.md\":\"237a2a6a\",\"base_element_index.md\":\"89357051\",\"base_eslint_ellint.md\":\"ed5245f3\",\"base_git_git.md\":\"94bdb8c9\",\"base_git_index.md\":\"0703fa56\",\"base_gitee_gitee.md\":\"cab28a11\",\"base_index.md\":\"2c3d9022\",\"base_javascript_index.md\":\"763b15a0\",\"base_jenkins_index.md\":\"4f161285\",\"base_k8s_changelog.md\":\"b3602f66\",\"base_k8s_index.md\":\"7566b1e3\",\"base_lerna_index.md\":\"c101cd05\",\"base_linux_desktop-environment_desktop-environment.md\":\"e98166a4\",\"base_linux_distribution_fedora_fedora.md\":\"27cd3611\",\"base_linux_distribution_deepin_deepin.md\":\"6d619bd8\",\"base_linux_distribution_release-linux.md\":\"b9f41044\",\"base_linux_index.md\":\"3b9628c0\",\"base_linux_linux运维管理.md\":\"131c0685\",\"base_markdown_markdown.md\":\"d0c50375\",\"base_node_index.md\":\"82ac46bf\",\"base_node_package.json.md\":\"5dcd94a1\",\"base_npm_index.md\":\"77335796\",\"base_pnpm_index.md\":\"3720ecc2\",\"base_rancher_rancher_v1.x.md\":\"737d5024\",\"base_sprint_sprintboot_index.md\":\"a3803d2f\",\"base_typescript_typescript 2.md\":\"5c9d9fc7\",\"base_typescript_typescript.md\":\"2107d092\",\"base_v8_index.md\":\"ff3988a2\",\"base_vite_index.md\":\"8c652462\",\"base_vite_vite.md\":\"2a219f01\",\"base_vitepress_index.md\":\"1d84b7f6\",\"base_vscode_configuration.md\":\"0544a770\",\"base_vscode_devextension.md\":\"943eea8d\",\"base_vscode_index.md\":\"fd79141e\",\"base_vscode_index的副本.md\":\"c01426cf\",\"base_vscode_setting.vscode.wit.md\":\"e7d097ce\",\"base_vscode_vscode.md\":\"dbf5c04b\",\"base_vue_cli.md\":\"887006a7\",\"base_vue_compile 2.md\":\"abcbe179\",\"base_vue_compile.md\":\"3bc59f4f\",\"base_vue_composition-api-vue2.md\":\"e7ddbfa4\",\"base_vue_index 2.md\":\"7a06bd7b\",\"base_vue_index.md\":\"f58fe564\",\"base_vue_rule 2.md\":\"d05982e0\",\"base_vue_rule.md\":\"50c0dde7\",\"base_vue_vuecli_index.md\":\"f17a3bc1\",\"base_vuecli_index.md\":\"141ebc83\",\"base_wechat_index.md\":\"9feec7b6\",\"base_windows_window.md\":\"8a580416\",\"base_windows_windows.md\":\"5dbcbfed\",\"base_winget_index.md\":\"85597476\",\"base_winget_package.json.md\":\"494751ea\",\"base_yarn_index.md\":\"169d3711\",\"data_常用算法.md\":\"fb437b77\",\"data_数据结构.md\":\"f105a4dc\",\"data_算法题.md\":\"e7f551f0\",\"economics_daikuan.md\":\"5fbc18c8\",\"hardware_car_jeep_index.md\":\"d5c72757\",\"hardware_earphone_index.md\":\"2712d9ac\",\"hardware_index.md\":\"9a014f54\",\"hardware_ipad.md\":\"bd7dc48e\",\"hardware_keyboard_index.md\":\"5a8e9df6\",\"hardware_pc.md\":\"f80bac39\",\"hardware_phone.md\":\"1f8b0565\",\"hardware_人体工学椅.md\":\"3663023d\",\"hardware_接口.md\":\"1941bec4\",\"index.md\":\"129099ac\",\"movies_index.md\":\"4df168f8\",\"net_56_109.md\":\"a1402b78\",\"net_56_110.md\":\"11434ea4\",\"net_56_index.md\":\"7d8e261d\",\"net_netprotocal_http_index.md\":\"f374b289\",\"net_netprotocal_http2_index.md\":\"a743506a\",\"net_netprotocal_index.md\":\"29fe4819\",\"net_browser_index.md\":\"356857d9\",\"net_domains_index.md\":\"2b1ab77b\",\"net_gfw.md\":\"4ac408c0\",\"net_index 2.md\":\"03d74029\",\"net_index.md\":\"bf0e58ce\",\"net_监控_index.md\":\"c87f8a3c\",\"net_监控_前端监控 sdk 的一些技术要点原理分析.md\":\"94fb4204\",\"net_监控_前端监控平台系列：js sdk（已开源）.md\":\"994dd3cf\",\"net_监控_前端监控平台系列：服务端功能设计与实现.md\":\"ecf7f010\",\"net_网络协议_index.md\":\"d81eebe7\",\"net_路由器_路由器.md\":\"7b473456\",\"os_filesystem.md\":\"94224199\",\"os_cardos_index.md\":\"6a54979f\",\"os_kernel-windows.md\":\"95305664\",\"os_uos_index.md\":\"b24fb656\",\"os_windows_windows-kernel_filesystem-windows.md\":\"e781039b\",\"os_windows_windows-kernel_powershell.md\":\"087cf6fd\",\"os_windows_windows-kernel_tools-windows.md\":\"879becc1\",\"os_windows_windows-kernel_windows.md\":\"74542254\",\"os_windows_windows-kernel_垃圾清理.md\":\"a61d7f0f\",\"software_a-tools.md\":\"2d8b3a4d\",\"software_browser_index.md\":\"4c792ac1\",\"software_download-tools.md\":\"6b3fce1a\",\"software_index.md\":\"e824bbad\",\"software_news21-05.hardware.md\":\"92971134\",\"software_news21.software.md\":\"3f581dd7\",\"todos_index.md\":\"e0ca8b4d\",\"topic_bigdata_index.md\":\"853970c5\",\"topic_container_index.md\":\"c6882023\",\"topic_data-visualization_139_03.md\":\"9e00128a\",\"topic_data-visualization_139_04.md\":\"edf7c329\",\"topic_data-visualization_139_05.md\":\"dba3a698\",\"topic_data-visualization_139_06.md\":\"05c7bb98\",\"topic_data-visualization_139_index.md\":\"b190bfca\",\"topic_data-visualization_index.md\":\"8596728a\",\"topic_frontend_components_login.md\":\"1ff239d9\",\"topic_frontend_components_scrollbar_scrollbar.md\":\"fe6a3423\",\"topic_frontend_components_tree-select_index.md\":\"14f8be1f\",\"topic_frontend_index.md\":\"4165fd0f\",\"topic_frontend_portal_index.md\":\"cf51fc78\",\"topic_frontend_router_index.md\":\"2e57383b\",\"topic_frontend_router_router.md\":\"9eca97ed\",\"topic_frontend_template_template.md\":\"2beacd66\",\"topic_frontend_vscode_index.md\":\"86357607\",\"topic_frontend_数据埋点规范.md\":\"b85ad9fd\",\"topic_frontend_登录鉴权_index.md\":\"32a01b9a\",\"topic_frontend_跨端方案_index.md\":\"ae827069\",\"topic_index.md\":\"861e0c40\",\"topic_leader.md\":\"f3195180\",\"topic_license_license.md\":\"2f02a5af\",\"topic_manamge.md\":\"e983891f\",\"topic_materials-vue2_index.md\":\"b407d3d6\",\"topic_micro-soa_index.md\":\"e4d81f9b\",\"topic_programming-paradigm_programming-paradigm.md\":\"691bf1b6\",\"topic_tdd_index.md\":\"88a3a084\",\"topic_tree-shaking_index.md\":\"a8562cf8\",\"topic_webadmin_index.md\":\"e8e6b04f\",\"topic_哲学_国学.md\":\"0123d402\",\"topic_计算机编码_计算机编码.md\":\"dc832859\"}")</script>
    <script type="module" async src="/assets/app.79b189f8.js"></script>
    
  </body>
</html>